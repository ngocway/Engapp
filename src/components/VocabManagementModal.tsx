import React, { useState, useEffect } from 'react';
import { Passage, PassageVocab } from '../types';
import { CambridgeDictionaryService } from '../services/cambridgeDictionaryService';
import { uploadImageToStorage, deleteImageFromStorage, validateImageFile, validateAudioFile, uploadVocabImage, uploadVocabAudio } from '../firebase/storageService';

interface VocabManagementModalProps {
  passage: Passage | null;
  isOpen: boolean;
  onClose: () => void;
}

const VocabManagementModal: React.FC<VocabManagementModalProps> = ({
  passage,
  isOpen,
  onClose
}) => {
  const [vocabList, setVocabList] = useState<PassageVocab[]>([]);
  const [loading, setLoading] = useState(false);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [showEditModal, setShowEditModal] = useState(false);
  const [editingVocab, setEditingVocab] = useState<PassageVocab | null>(null);
  const [uploadedImage, setUploadedImage] = useState<string | null>(null);
  const [uploadedAudio, setUploadedAudio] = useState<string | null>(null);
  const [uploadingImage, setUploadingImage] = useState(false);
  const [uploadingAudio, setUploadingAudio] = useState(false);
  const [generatingSample, setGeneratingSample] = useState(false);

  useEffect(() => {
    if (passage && isOpen) {
      loadVocabList();
    } else {
      setVocabList([]);
    }
  }, [passage, isOpen]);

  const loadVocabList = async () => {
    if (!passage) return;
    
    try {
      setLoading(true);
      console.log('üìö Loading vocabulary for passage:', passage.title);
      console.log('üìö Passage vocab data:', passage.vocab);
      console.log('üìö Passage ID:', passage.id);
      
      // Load vocabulary directly from passage.vocab
      let vocabData = passage.vocab || [];
      
      // If no vocab in passage, try to load from database (fallback)
      if (vocabData.length === 0) {
        console.log('üìö No vocab in passage, trying to load from database...');
        const { passageService } = await import('../firebase/passageService');
        const freshPassage = await passageService.getPassageById(passage.id);
        if (freshPassage && freshPassage.vocab) {
          vocabData = freshPassage.vocab;
          console.log('üìö Found vocab in fresh passage:', vocabData);
        } else {
          console.log('üìö No vocab field found in database, initializing empty array');
          // Initialize empty vocab field in database if it doesn't exist
          try {
            await passageService.update(passage.id, { vocab: [] });
            console.log('üìö Initialized empty vocab field in database');
          } catch (error) {
            console.error('‚ùå Failed to initialize vocab field:', error);
          }
        }
      }
      
      setVocabList(vocabData);
      console.log('üìö Final vocab data:', vocabData);
      console.log('üìö VocabList length:', vocabData.length);
    } catch (error) {
      console.error('Error loading vocabulary:', error);
      setVocabList([]);
    } finally {
      setLoading(false);
    }
  };

  const addVocabField = () => {
    const newVocab: PassageVocab = {
      term: '',
      meaning: '',
      pronunciation: '',
      image: '',
      partOfSpeech: '',
      example: ''
    };
    const newIndex = vocabList.length;
    setVocabList([...vocabList, newVocab]);
    // T·ª± ƒë·ªông m·ªü popup edit cho t·ª´ v·ª±ng m·ªõi
    setEditingIndex(newIndex);
    setEditingVocab({ ...newVocab });
    setShowEditModal(true);
  };

  const openEditModal = (index: number) => {
    const vocab = vocabList[index];
    setEditingIndex(index);
    setEditingVocab({ ...vocab });
    
    // Load existing uploaded files if any
    setUploadedImage(vocab.image || null);
    setUploadedAudio(vocab.audio || null);
    
    setShowEditModal(true);
  };

  const closeEditModal = () => {
    setShowEditModal(false);
    setEditingIndex(null);
    setEditingVocab(null);
    setUploadedImage(null);
    setUploadedAudio(null);
  };

  const updateVocabField = (index: number, field: keyof PassageVocab, value: string) => {
    const newVocab = [...vocabList];
    newVocab[index] = { ...newVocab[index], [field]: value };
    setVocabList(newVocab);
    
    console.log(`üìù Updated ${field} for index ${index}:`, value);
  };

  const updateEditingVocab = (field: keyof PassageVocab, value: string) => {
    if (editingVocab) {
      setEditingVocab({ ...editingVocab, [field]: value });
    }
  };

  // Function ƒë·ªÉ l∆∞u vocabulary v√†o database
  const saveVocabToDatabase = async (vocabListToSave: PassageVocab[]) => {
    try {
      setLoading(true);
      
      // Prepare vocabulary data for passage.vocab
      const cleanVocabList = vocabListToSave
        .filter(vocab => vocab.term.trim() !== '') // Only save non-empty terms
        .map(vocab => {
          const vocabData: PassageVocab = {
            term: vocab.term.trim(),
            meaning: vocab.meaning.trim(),
            definitionEn: vocab.definitionEn?.trim() || vocab.meaning.trim() // Use definitionEn if available, fallback to meaning
          };
          
          // Add phonetics if provided (∆∞u ti√™n phonetics object, fallback v·ªÅ pronunciation)
          if (vocab.phonetics) {
            vocabData.phonetics = vocab.phonetics;
          } else if (vocab.pronunciation && vocab.pronunciation.trim() !== '') {
            vocabData.phonetics = { us: vocab.pronunciation.trim() };
          }
          
          // Add image if provided
          if (vocab.image && vocab.image.trim() !== '') {
            vocabData.image = vocab.image.trim();
          }
          
          // Add part of speech if provided
          if (vocab.partOfSpeech && vocab.partOfSpeech.trim() !== '') {
            vocabData.partOfSpeech = vocab.partOfSpeech.trim();
          }
          
          // Add example if provided
          if (vocab.example && vocab.example.trim() !== '') {
            vocabData.example = vocab.example.trim();
          }
          
          // Add multiple examples if provided
          if (vocab.examples && vocab.examples.length > 0) {
            vocabData.examples = vocab.examples.filter(ex => ex.trim() !== '');
          }
          
          // Add audio if provided
          if (vocab.audio && vocab.audio.trim() !== '') {
            vocabData.audio = vocab.audio.trim();
          }
          
          console.log('üíæ Preparing vocab:', vocabData);
          return vocabData;
        });
      
      // Update passage with new vocabulary
      const { passageService } = await import('../firebase/passageService');
      await passageService.update(passage!.id, { vocab: cleanVocabList });
      
      // Also save individual vocabulary items to vocabulary collection
      const { vocabularyService } = await import('../firebase/vocabularyService');
      for (const vocabData of cleanVocabList) {
        // Check if vocabulary already exists
        const existingVocab = await vocabularyService.getVocabularyByWord(vocabData.term);
        if (existingVocab) {
          // Update existing vocabulary
          await vocabularyService.updateVocabulary(existingVocab.id, vocabData);
          console.log(`‚úÖ Updated vocabulary: ${vocabData.term}`);
        } else {
          // Add new vocabulary
          const vocabId = await vocabularyService.addVocabulary({
            word: vocabData.term,
            meaning: vocabData.meaning,
            pronunciation: vocabData.phonetics?.us || '',
            image: vocabData.image || '',
            audioUrl: vocabData.audio || '',
            example: vocabData.example || '',
            examples: vocabData.examples || [],
            partOfSpeech: vocabData.partOfSpeech || '',
            definitionEn: vocabData.definitionEn || ''
          });
          if (vocabId) {
            console.log(`‚úÖ Added new vocabulary: ${vocabData.term} with ID: ${vocabId}`);
          }
        }
      }
      
      console.log('‚úÖ Vocabulary saved to both passage.vocab and vocabulary collection successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Error saving vocabulary:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const saveEditChanges = async () => {
    if (editingIndex !== null && editingVocab) {
      try {
        const newVocabList = [...vocabList];
        const updatedVocab = { ...editingVocab };
        
        
        // S·ª≠ d·ª•ng ·∫£nh ƒë√£ upload n·∫øu c√≥
        if (uploadedImage) {
          updatedVocab.image = uploadedImage;
        }
        
        // S·ª≠ d·ª•ng audio ƒë√£ upload n·∫øu c√≥
        if (uploadedAudio) {
          updatedVocab.audio = uploadedAudio;
        }
        
        newVocabList[editingIndex] = updatedVocab;
        setVocabList(newVocabList);
        
        // L∆∞u tr·ª±c ti·∫øp v√†o database
        await saveVocabToDatabase(newVocabList);
        
        alert('‚úÖ ƒê√£ l∆∞u t·ª´ v·ª±ng v√†o database th√†nh c√¥ng!');
        closeEditModal();
      } catch (error) {
        alert('‚ùå L·ªói khi l∆∞u t·ª´ v·ª±ng v√†o database');
        console.error('Error in saveEditChanges:', error);
      }
    }
  };

  const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !editingVocab?.term) return;

    // Validate file
    const validation = validateImageFile(file);
    if (!validation.valid) {
      alert(validation.error);
      return;
    }

    setUploadingImage(true);
    try {
      // Upload to Firebase Storage
      const result = await uploadVocabImage(file, editingVocab.term);
      
      if (result.success && result.url) {
        setUploadedImage(result.url);
        // C·∫≠p nh·∫≠t editingVocab v·ªõi URL ·∫£nh m·ªõi
        setEditingVocab({ ...editingVocab, image: result.url });
        console.log('‚úÖ Image uploaded successfully:', result.url);
      } else {
        alert(`‚ùå L·ªói upload ·∫£nh: ${result.error}`);
      }
    } catch (error) {
      console.error('‚ùå Error uploading image:', error);
      alert('‚ùå L·ªói khi upload ·∫£nh l√™n Firebase Storage');
    } finally {
      setUploadingImage(false);
    }
  };

  const handleAudioUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !editingVocab?.term) return;

    // Validate file
    const validation = validateAudioFile(file);
    if (!validation.valid) {
      alert(validation.error);
      return;
    }

    setUploadingAudio(true);
    try {
      // Upload to Firebase Storage
      const result = await uploadVocabAudio(file, editingVocab.term);
      
      if (result.success && result.url) {
        setUploadedAudio(result.url);
        // C·∫≠p nh·∫≠t editingVocab v·ªõi URL audio m·ªõi
        setEditingVocab({ ...editingVocab, audio: result.url });
        console.log('‚úÖ Audio uploaded successfully:', result.url);
      } else {
        alert(`‚ùå L·ªói upload audio: ${result.error}`);
      }
    } catch (error) {
      console.error('‚ùå Error uploading audio:', error);
      alert('‚ùå L·ªói khi upload audio l√™n Firebase Storage');
    } finally {
      setUploadingAudio(false);
    }
  };

  const generateSampleData = async () => {
    if (!editingVocab?.term) {
      alert('Vui l√≤ng nh·∫≠p t·ª´ v·ª±ng tr∆∞·ªõc khi generate sample data');
      return;
    }

    try {
      setGeneratingSample(true);
      const sampleData = await CambridgeDictionaryService.generateSampleVocabData(editingVocab.term);
      
      if (sampleData) {
        // Update editing vocab with sample data
        const updatedVocab = {
          ...editingVocab,
          ...sampleData
        };
        
        setEditingVocab(updatedVocab);
        
        // Update uploaded files if provided
        if (sampleData.image) {
          setUploadedImage(sampleData.image);
        }
        if (sampleData.audio) {
          setUploadedAudio(sampleData.audio);
        }
        
        console.log(`‚úÖ ƒê√£ generate sample data th√†nh c√¥ng! T·ª´: ${sampleData.term}, Nghƒ©a: ${sampleData.meaning}, Ph√°t √¢m: ${sampleData.pronunciation}`);
      } else {
        console.error('‚ùå Kh√¥ng th·ªÉ generate sample data');
      }
    } catch (error) {
      console.error('Error generating sample data:', error);
    } finally {
      setGeneratingSample(false);
    }
  };



  const validateVocabList = () => {
    const errors: string[] = [];
    
    vocabList.forEach((vocab, index) => {
      if (vocab.term.trim() === '') {
        errors.push(`T·ª´ v·ª±ng th·ª© ${index + 1}: Thi·∫øu t·ª´ v·ª±ng`);
      }
      if (vocab.meaning.trim() === '') {
        errors.push(`T·ª´ v·ª±ng th·ª© ${index + 1}: Thi·∫øu nghƒ©a`);
      }
    });
    
    return errors;
  };

  const handleSaveAndClose = async () => {
    // ƒê√≥ng t·∫•t c·∫£ ch·∫ø ƒë·ªô edit tr∆∞·ªõc khi l∆∞u
    setEditingIndex(null);
    
    // Validate v√† l∆∞u
    await handleSave();
  };

  const handleSave = async () => {
    if (!passage) return;
    
    // Validate before saving
    const validationErrors = validateVocabList();
    if (validationErrors.length > 0) {
      alert('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin:\n' + validationErrors.join('\n'));
      return;
    }
    
    try {
      console.log('üíæ Saving vocabulary for passage:', passage.title);
      
      // S·ª≠ d·ª•ng function saveVocabToDatabase ƒë√£ t√°ch ri√™ng
      await saveVocabToDatabase(vocabList);
      
      alert('‚úÖ ƒê√£ l∆∞u t·ª´ v·ª±ng th√†nh c√¥ng!');
      onClose();
    } catch (error) {
      console.error('‚ùå Error saving vocabulary:', error);
      alert('‚ùå L·ªói khi l∆∞u t·ª´ v·ª±ng');
    }
  };

  if (!isOpen || !passage) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content vocab-management-modal">
        <div className="modal-header">
          <h2>üìö Qu·∫£n l√Ω t·ª´ v·ª±ng - {passage.title}</h2>
          <button className="modal-close" onClick={onClose}>
            ‚úï
          </button>
        </div>

        <div className="modal-body">
          {loading && vocabList.length === 0 ? (
            <div className="loading-container">
              <div className="loading-spinner"></div>
              <p>ƒêang t·∫£i t·ª´ v·ª±ng...</p>
            </div>
          ) : (
            <>
              <div className="vocab-header">
                <span>Danh s√°ch t·ª´ v·ª±ng ({vocabList.length})</span>
                <button
                  type="button"
                  className="add-vocab-btn"
                  onClick={addVocabField}
                >
                  + Th√™m t·ª´ v·ª±ng
                </button>
              </div>
              
              {vocabList.length === 0 ? (
                <div className="no-vocab-message">
                  <p>Ch∆∞a c√≥ t·ª´ v·ª±ng n√†o. Nh·∫•n "Th√™m t·ª´ v·ª±ng" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
                </div>
              ) : (
                <div className="vocab-list">
                  {vocabList.map((vocab, index) => (
                    <div key={index} className="vocab-item">
                      <div className="vocab-display">
                        {/* Thumbnail v√† t·ª´ v·ª±ng */}
                        <div 
                          className="vocab-thumbnail-container"
                          onClick={() => openEditModal(index)}
                          style={{ cursor: 'pointer' }}
                          title="Click ƒë·ªÉ ch·ªânh s·ª≠a t·ª´ v·ª±ng"
                        >
                          <div className="vocab-thumbnail">
                            {vocab.image && vocab.image.trim() !== '' ? (
                              <img 
                                src={vocab.image} 
                                alt={vocab.term || 'T·ª´ v·ª±ng'} 
                                className="vocab-thumbnail-image"
                                onError={(e) => {
                                  const target = e.target as HTMLImageElement;
                                  target.style.display = 'none';
                                  target.nextElementSibling?.classList.remove('hidden');
                                }}
                              />
                            ) : null}
                            <div className={`vocab-thumbnail-placeholder ${vocab.image && vocab.image.trim() !== '' ? 'hidden' : ''}`}>
                              <span className="placeholder-icon">üñºÔ∏è</span>
                              <span className="placeholder-text">Ch∆∞a c√≥ ·∫£nh</span>
                            </div>
                          </div>
                          <div className="vocab-word">
                            {vocab.term || 'T·ª´ v·ª±ng'}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
              
              <div className="vocab-info">
                <p><small>üí° T·ª´ v·ª±ng s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o database v√† hi·ªÉn th·ªã cho h·ªçc vi√™n.</small></p>
              </div>
            </>
          )}
        </div>

        <div className="modal-footer">
          <button 
            className="btn-secondary" 
            onClick={onClose}
            disabled={loading}
          >
            H·ªßy
          </button>
          <button 
            className="btn-primary" 
            onClick={handleSaveAndClose}
            disabled={loading}
          >
            {loading ? 'ƒêang l∆∞u...' : 'L∆∞u t·ª´ v·ª±ng'}
          </button>
        </div>
      </div>

      {/* Edit Vocab Popup Modal */}
      {showEditModal && editingVocab && (
        <div className="modal-overlay">
          <div className="modal-content vocab-edit-modal">
            <div className="modal-header">
              <h2>‚úèÔ∏è Ch·ªânh s·ª≠a t·ª´ v·ª±ng</h2>
              <button className="modal-close" onClick={closeEditModal}>
                ‚úï
              </button>
            </div>

            <div className="modal-body">
              <div className="edit-vocab-form">
                <div className="vocab-field">
                  <label>·∫¢nh ƒë·∫°i di·ªán:</label>
                  
                  {/* File Upload Option */}
                  <div className="upload-section">
                    <input
                      type="file"
                      accept="image/*"
                      onChange={handleImageUpload}
                      className="file-input"
                      id="image-upload"
                    />
                    <label htmlFor="image-upload" className={`file-upload-btn ${uploadingImage ? 'uploading' : ''}`}>
                      {uploadingImage ? '‚è≥ ƒêang upload...' : 'üìÅ Ch·ªçn ·∫£nh t·ª´ m√°y t√≠nh'}
                    </label>
                  </div>
                  
                  {/* URL Input Option */}
                  <div className="url-section">
                    <input
                      type="url"
                      value={editingVocab.image || ''}
                      onChange={(e) => updateEditingVocab('image', e.target.value)}
                      placeholder="Ho·∫∑c nh·∫≠p URL ·∫£nh t·ª´ internet"
                      className="image-url-input"
                    />
                  </div>
                  
                  {/* Preview image */}
                  {(uploadedImage || editingVocab.image) && (
                    <div className="image-preview">
                      <img 
                        src={uploadedImage || editingVocab.image} 
                        alt="Preview" 
                        className="preview-image" 
                        onError={(e) => {
                          const target = e.target as HTMLImageElement;
                          target.style.display = 'none';
                        }}
                      />
                      <button 
                        type="button" 
                        className="remove-image-btn"
                        onClick={() => {
                          setUploadedImage(null);
                          updateEditingVocab('image', '');
                        }}
                      >
                        ‚úï X√≥a ·∫£nh
                      </button>
                    </div>
                  )}
                  
                  <small className="field-help">üí° Upload ·∫£nh t·ª´ m√°y t√≠nh (jpg, png, gif, webp) ho·∫∑c nh·∫≠p URL</small>
                </div>
                
                <div className="vocab-field">
                  <label>T·ª´ v·ª±ng: <span style={{color: 'red'}}>*</span></label>
                  <div className="term-input-container">
                    <input
                      type="text"
                      value={editingVocab.term}
                      onChange={(e) => updateEditingVocab('term', e.target.value)}
                      placeholder="Nh·∫≠p t·ª´ v·ª±ng"
                      className={`term-input ${editingVocab.term.trim() === '' ? 'required-field' : ''}`}
                    />
                    <button
                      type="button"
                      className="generate-sample-btn"
                      onClick={generateSampleData}
                      disabled={generatingSample || !editingVocab?.term}
                      title="Generate sample data cho t·ª´ v·ª±ng"
                    >
                      {generatingSample ? 'üîÑ' : '‚ú®'}
                    </button>
                  </div>
                  {editingVocab.term.trim() === '' && (
                    <small className="field-warning">‚ö†Ô∏è Tr∆∞·ªùng n√†y l√† b·∫Øt bu·ªôc</small>
                  )}
                  <small className="field-help">üí° Nh·∫•n n√∫t ‚ú® ƒë·ªÉ t·ª± ƒë·ªông generate nghƒ©a, ph√°t √¢m, ·∫£nh, audio, v√≠ d·ª•...</small>
                </div>
                
                <div className="vocab-field">
                  <label>Nghƒ©a: <span style={{color: 'red'}}>*</span></label>
                  <textarea
                    value={editingVocab.meaning}
                    onChange={(e) => updateEditingVocab('meaning', e.target.value)}
                    placeholder="Nh·∫≠p nghƒ©a ti·∫øng Vi·ªát"
                    rows={3}
                    className={`${editingVocab.meaning.trim() === '' ? 'required-field' : ''}`}
                  />
                  {editingVocab.meaning.trim() === '' && (
                    <small className="field-warning">‚ö†Ô∏è Tr∆∞·ªùng n√†y l√† b·∫Øt bu·ªôc</small>
                  )}
                </div>
                
                <div className="vocab-field">
                  <label>Ph√°t √¢m (t√πy ch·ªçn):</label>
                  <input
                    type="text"
                    value={editingVocab.pronunciation || editingVocab.phonetics?.us || ''}
                    onChange={(e) => {
                      const newVocab = { 
                        ...editingVocab, 
                        pronunciation: e.target.value,
                        phonetics: { us: e.target.value }
                      };
                      setEditingVocab(newVocab);
                    }}
                    placeholder="V√≠ d·ª•: /Ààw äd…ôn/ ho·∫∑c /m…™st/"
                  />
                  <small className="field-help">üí° S·ª≠ d·ª•ng k√Ω hi·ªáu IPA ho·∫∑c phi√™n √¢m ti·∫øng Vi·ªát</small>
                </div>
                
                <div className="vocab-field">
                  <label>ƒê·ªãnh nghƒ©a ti·∫øng Anh (t√πy ch·ªçn):</label>
                  <textarea
                    value={editingVocab.definitionEn || ''}
                    onChange={(e) => updateEditingVocab('definitionEn', e.target.value)}
                    placeholder="Nh·∫≠p ƒë·ªãnh nghƒ©a ti·∫øng Anh c·ªßa t·ª´ v·ª±ng"
                    rows={2}
                  />
                  <small className="field-help">üí° ƒê·ªãnh nghƒ©a ti·∫øng Anh gi√∫p h·ªçc vi√™n hi·ªÉu r√µ h∆°n v·ªÅ t·ª´ v·ª±ng</small>
                </div>
                
                <div className="vocab-field">
                  <label>Audio ph√°t √¢m (t√πy ch·ªçn):</label>
                  
                  
                  {/* File Upload Option */}
                  <div className="upload-section">
                    <input
                      type="file"
                      accept="audio/*"
                      onChange={handleAudioUpload}
                      className="file-input"
                      id="audio-upload"
                    />
                    <label htmlFor="audio-upload" className={`file-upload-btn ${uploadingAudio ? 'uploading' : ''}`}>
                      {uploadingAudio ? '‚è≥ ƒêang upload...' : 'üéµ Ch·ªçn file audio t·ª´ m√°y t√≠nh'}
                    </label>
                  </div>
                  
                  {/* Preview audio */}
                  {(uploadedAudio || editingVocab.audio) && (
                    <div className="audio-preview">
                      <div className="audio-preview-header">
                        <span className="audio-label">üéµ Audio ph√°t √¢m:</span>
                        <button 
                          type="button" 
                          className="remove-audio-btn"
                          onClick={() => {
                            setUploadedAudio(null);
                            updateEditingVocab('audio', '');
                          }}
                          title="X√≥a audio"
                        >
                          ‚úï
                        </button>
                      </div>
                      <div className="audio-player-container">
                        <div className="audio-controls">
                          <button
                            type="button"
                            className="play-audio-btn"
                            onClick={() => {
                              // T√¨m audio element trong modal n√†y
                              const modalAudio = document.querySelector('.vocab-edit-modal audio') as HTMLAudioElement;
                              if (modalAudio) {
                                modalAudio.play().catch(error => {
                                  console.error('‚ùå Error playing audio:', error);
                                  alert('‚ùå Kh√¥ng th·ªÉ ph√°t audio. Vui l√≤ng ki·ªÉm tra file audio.');
                                });
                              } else {
                                console.error('‚ùå Audio element not found');
                                alert('‚ùå Kh√¥ng t√¨m th·∫•y audio element');
                              }
                            }}
                          >
                            ‚ñ∂Ô∏è Nghe th·ª≠
                          </button>
                          <audio 
                            key={uploadedAudio || editingVocab.audio} // Force re-render when audio changes
                            src={uploadedAudio || editingVocab.audio}
                            controls 
                            className="preview-audio"
                            preload="metadata"
                          >
                            Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ph√°t audio.
                          </audio>
                        </div>
                      </div>
                      <div className="audio-info">
                        <small>üí° Nh·∫•n play ƒë·ªÉ nghe th·ª≠ audio ƒë√£ upload</small>
                      </div>
                    </div>
                  )}
                  
                  <small className="field-help">üí° Upload file audio t·ª´ m√°y t√≠nh (mp3, wav, ogg) ƒë·ªÉ ph√°t √¢m t·ª´ v·ª±ng</small>
                </div>
                
                <div className="vocab-field">
                  <label>Lo·∫°i t·ª´ (t√πy ch·ªçn):</label>
                  <input
                    type="text"
                    value={editingVocab.partOfSpeech || ''}
                    onChange={(e) => updateEditingVocab('partOfSpeech', e.target.value)}
                    placeholder="V√≠ d·ª•: noun, verb, adjective"
                  />
                </div>
                
                <div className="vocab-field">
                  <label>V√≠ d·ª• (t√πy ch·ªçn):</label>
                  
                  {/* Primary Example */}
                  <div className="example-section">
                    <label className="sub-label">V√≠ d·ª• ch√≠nh:</label>
                    <textarea
                      value={editingVocab.example || ''}
                      onChange={(e) => updateEditingVocab('example', e.target.value)}
                      placeholder="Nh·∫≠p c√¢u v√≠ d·ª• ch√≠nh"
                      rows={2}
                      className="primary-example"
                    />
                  </div>
                  
                  {/* Multiple Examples */}
                  <div className="examples-section">
                    <div className="examples-header">
                      <label className="sub-label">Danh s√°ch v√≠ d·ª•:</label>
                      <button
                        type="button"
                        className="add-example-btn"
                        onClick={() => {
                          const currentExamples = editingVocab.examples || [];
                          const newExamples = [...currentExamples, ''];
                          setEditingVocab({ ...editingVocab, examples: newExamples });
                        }}
                        title="Th√™m v√≠ d·ª• m·ªõi"
                      >
                        + Th√™m v√≠ d·ª•
                      </button>
                    </div>
                    
                    <div className="examples-list">
                      {(editingVocab.examples || []).map((example, index) => (
                        <div key={index} className="example-item">
                          <div className="example-number">#{index + 1}</div>
                          <textarea
                            value={example}
                            onChange={(e) => {
                              const newExamples = [...(editingVocab.examples || [])];
                              newExamples[index] = e.target.value;
                              setEditingVocab({ ...editingVocab, examples: newExamples });
                            }}
                            placeholder={`Nh·∫≠p v√≠ d·ª• ${index + 1}`}
                            rows={2}
                            className="example-textarea"
                          />
                          <button
                            type="button"
                            className="remove-example-btn"
                            onClick={() => {
                              const newExamples = (editingVocab.examples || []).filter((_, i) => i !== index);
                              setEditingVocab({ ...editingVocab, examples: newExamples });
                            }}
                            title="X√≥a v√≠ d·ª• n√†y"
                          >
                            ‚úï
                          </button>
                        </div>
                      ))}
                    </div>
                    
                    {(!editingVocab.examples || editingVocab.examples.length === 0) && (
                      <div className="no-examples-message">
                        <p>Ch∆∞a c√≥ v√≠ d·ª• n√†o. Nh·∫•n "Th√™m v√≠ d·ª•" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>

            <div className="modal-footer">
              <button 
                className="btn-secondary" 
                onClick={closeEditModal}
              >
                H·ªßy
              </button>
              <button 
                className="btn-primary" 
                onClick={saveEditChanges}
                disabled={!editingVocab.term.trim() || !editingVocab.meaning.trim()}
              >
                L∆∞u thay ƒë·ªïi
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default VocabManagementModal;
